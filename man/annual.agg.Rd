% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/annual.agg.R
\name{annual.agg}
\alias{annual.agg}
\alias{yearly.agg}
\alias{monthly.agg}
\title{Annual (maxima or minima) (default) aggregation}
\usage{
annual.agg(
  x,
  time,
  index = as.character(lubridate::year(time)),
  dd = c(1, 2, 5),
  aggr.fun = "max",
  na.rm = TRUE,
  dd_formatter = "D\%03d",
  numeric_dd = TRUE,
  numeric_index = FALSE,
  aggr.name = "aggr",
  dd.name = "dd",
  index.name = "index",
  filter = lapply(dd, function(dd) {
     rep(1, dd)/dd
 }),
  method = "convolution",
  sides = 1,
  return_vector = FALSE,
  order_time = TRUE,
  speed_up = FALSE,
  ...
)

yearly.agg(x, time, ...)

monthly.agg(
  x,
  time,
  index = sprintf("\%04d_\%02d", lubridate::year(time), lubridate::month(time)),
  ...
)
}
\arguments{
\item{x}{vector or time series}

\item{time}{vector of time index (e.g. \code{Date} or \code{POSIXct})}

\item{index}{index aggregation vector. Default is \code{as.character(lubridate::year(time))} (e.g every year)}

\item{dd}{duration for the moving window. More than 1 duration can be assigned.}

\item{aggr.fun}{atomic aggregation function (e.g. \code{\link{max}} or \code{\link{min}}), accepting \code{na.rm} argument.}

\item{na.rm}{argument for \code{aggr.fun}}

\item{dd_formatter}{string formatter for duration in the function value}

\item{numeric_dd}{logical. Default is \code{TRUE}.}

\item{numeric_index}{logical. Default is \code{FALSE}.}

\item{aggr.name, dd.name, index.name}{optional column names of function results. See function usage.}

\item{filter, method, sides, ...}{further arguments for \code{stats::\link[stats]{filter}}}

\item{return_vector}{logical. If \code{TRUE} function return a vector through \code{\link{df2vec}}. Default is \code{FALSE}.}

\item{order_time}{logical argument, if it \code{TRUE} \code{x} is ordered following increasing \code{data}}

\item{speed_up}{logical argument}
}
\value{
a data frame or similar with index (e.g. year or year-month), duration (column name: \code{"dd"})  
and the aggregated value  (column name: \code{"aggr"})
}
\description{
Annual (maxima or minima) (default) aggregation
}
\examples{

library(RMAWGEN)
data(trentino)
time <- as.Date(sprintf("\%04d-\%02d-\%02d",PRECIPITATION$year,
PRECIPITATION$month,PRECIPITATION$day),format="\%Y-\%m-\%d")
x <- PRECIPITATION$B8570

out <- annual.agg(x,time)
out2 <- yearly.agg(x,time)


outv <- annual.agg(x,time,return_vector=TRUE)
outv1 <- vec2df(outv)

if (!identical(out,outv1)) stop("Something went wrong!")

library(lmom)
library(dplyr)
outp <- out \%>\% filter(dd==2)
evplot(outp$aggr)



outm <- annual.agg(x,time,index=sprintf("\%04d_\%02d",lubridate::year(time),
lubridate::month(time)))
outmd <- annual.agg(x,time,index=sprintf("\%04d_\%02d",lubridate::year(time),
lubridate::month(time)),aggr.fun=function(l,...) {which.max(l)})

### intesity greater or equal to 10 mm per day. 
funthres <- function(r,valmin=10,...) {length(which(r>=valmin))}
out_funthres <- annual.agg(x,time,index=sprintf("\%04d_\%02d",lubridate::year(time),
lubridate::month(time)),aggr.fun=funthres)
outv_funthres <- annual.agg(x,time,index=sprintf("\%04d_\%02d",lubridate::year(time),
lubridate::month(time)),aggr.fun=funthres,return_vector=TRUE)
outv_funthres <- monthly.agg(x,time,aggr.fun=funthres,return_vector=TRUE)
out2_funthres <- vec2df(outv_funthres)

if (!identical(out_funthres,out2_funthres)) stop("Something went wrong!")

}
\seealso{
\code{stats::\link[stats]{filter}},\code{\link{max}},\code{\link{min}}
}
